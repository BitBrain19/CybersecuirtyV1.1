"""
Malware Analysis Engine
Static analysis (PE parser, YARA scanner), dynamic analysis sandbox, clustering
"""

import asyncio
import json
import logging
import threading
import struct
import hashlib
import re
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from collections import defaultdict, Counter
import numpy as np

logger = logging.getLogger(__name__)


class MalwareFamily(str, Enum):
    """Known malware families"""
    TROJAN = "trojan"
    RANSOMWARE = "ransomware"
    WORM = "worm"
    ROOTKIT = "rootkit"
    SPYWARE = "spyware"
    ADWARE = "adware"
    BOTNET = "botnet"
    BACKDOOR = "backdoor"
    UNKNOWN = "unknown"


class ExecutableType(str, Enum):
    """Executable file types"""
    PE32 = "pe32"
    PE64 = "pe64"
    ELF32 = "elf32"
    ELF64 = "elf64"
    MACH_O = "mach_o"
    UNKNOWN = "unknown"


@dataclass
class PEHeader:
    """PE file header information"""
    machine_type: str
    number_of_sections: int
    timestamp: datetime
    pointer_to_symbol_table: int
    characteristics: List[str]
    subsystem: str
    dll_characteristics: List[str]


@dataclass
class PESection:
    """PE file section"""
    name: str
    virtual_size: int
    virtual_address: int
    size_of_raw_data: int
    pointer_to_raw_data: int
    characteristics: List[str]
    entropy: float = 0.0


@dataclass
class StaticAnalysisResult:
    """Static analysis findings"""
    file_hash_md5: str
    file_hash_sha256: str
    file_size: int
    executable_type: ExecutableType
    pe_header: Optional[PEHeader]
    sections: List[PESection]
    imports: Dict[str, List[str]]  # DLL -> functions
    exports: List[str]
    strings: List[str]
    suspected_api_calls: List[str]
    suspicious_sections: List[str]
    entropy_score: float  # 0-8, higher = more suspicious
    packer_detected: bool
    compiler: str
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class DynamicAnalysisResult:
    """Dynamic analysis sandbox results"""
    process_tree: Dict[str, Any]
    registry_modifications: List[Dict[str, Any]]
    file_operations: List[Dict[str, Any]]
    network_connections: List[Dict[str, Any]]
    spawned_processes: List[str]
    injected_processes: List[str]
    mutex_created: List[str]
    files_dropped: List[str]
    domains_contacted: List[str]
    ips_contacted: List[str]
    port_scans_detected: bool
    c2_communication: bool
    persistence_indicators: List[str]


@dataclass
class MalwareAnalysisReport:
    """Complete malware analysis report"""
    report_id: str
    sample_hash: str
    static_analysis: StaticAnalysisResult
    dynamic_analysis: Optional[DynamicAnalysisResult]
    detected_family: MalwareFamily
    malware_score: float  # 0-100
    confidence: float  # 0-1
    is_malicious: bool
    behavioral_indicators: List[str]
    iocs: List[str]
    remediation_steps: List[str]
    analysis_time: datetime = field(default_factory=datetime.now)


class PEFileParser:
    """Parser for PE (Portable Executable) files"""
    
    # PE header constants
    PE_SIGNATURE = b'PE\x00\x00'
    DOS_HEADER_SIZE = 64
    
    def __init__(self):
        self._lock = threading.RLock()
    
    def parse_dos_header(self, data: bytes) -> Tuple[bool, Optional[int]]:
        """Parse DOS header and return PE offset"""
        if len(data) < self.DOS_HEADER_SIZE:
            return False, None
        
        if data[0:2] != b'MZ':
            return False, None
        
        try:
            pe_offset = struct.unpack('<I', data[0x3c:0x40])[0]
            return True, pe_offset
        except:
            return False, None
    
    def parse_pe_header(self, data: bytes, pe_offset: int) -> Optional[PEHeader]:
        """Parse PE header"""
        try:
            if pe_offset + 24 > len(data):
                return None
            
            # PE signature
            if data[pe_offset:pe_offset+4] != self.PE_SIGNATURE:
                return None
            
            # COFF header (20 bytes after PE signature)
            coff_offset = pe_offset + 4
            machine_type, num_sections, timestamp, *rest = struct.unpack(
                '<HHIIIHH', data[coff_offset:coff_offset+20]
            )
            
            machine_names = {
                0x14c: 'i386',
                0x8664: 'x86-64',
                0xaa64: 'arm64',
            }
            
            header = PEHeader(
                machine_type=machine_names.get(machine_type, f'0x{machine_type:04x}'),
                number_of_sections=num_sections,
                timestamp=datetime.fromtimestamp(timestamp),
                pointer_to_symbol_table=rest[0],
                characteristics=[],
                subsystem='unknown',
                dll_characteristics=[]
            )
            
            return header
        except Exception as e:
            logger.error(f"Error parsing PE header: {e}")
            return None
    
    def calculate_entropy(self, data: bytes) -> float:
        """Calculate entropy of data (0-8, 7+ indicates compression/encryption)"""
        if len(data) == 0:
            return 0.0
        
        byte_freq = Counter(data)
        entropy = 0.0
        
        for count in byte_freq.values():
            probability = count / len(data)
            entropy -= probability * np.log2(probability)
        
        return float(entropy)
    
    def analyze_sections(self, data: bytes, pe_offset: int) -> List[PESection]:
        """Analyze PE sections"""
        sections = []
        
        try:
            # Optional header offset is after PE signature + COFF header
            opt_header_offset = pe_offset + 4 + 20
            
            # Skip optional header to get section headers
            if opt_header_offset + 2 > len(data):
                return sections
            
            opt_header_size = struct.unpack('<H', data[opt_header_offset:opt_header_offset+2])[0]
            section_offset = opt_header_offset + 4 + opt_header_size
            
            # Parse sections (40 bytes each)
            num_sections = 0
            while section_offset + 40 <= len(data) and num_sections < 32:
                section_data = data[section_offset:section_offset+40]
                
                name = section_data[0:8].strip(b'\x00').decode('utf-8', errors='ignore')
                virtual_size, virtual_addr, raw_size, raw_ptr, *flags = struct.unpack(
                    '<IIIIHH', section_data[8:36]
                )
                
                # Calculate section entropy
                if raw_ptr < len(data) and raw_ptr + raw_size <= len(data):
                    section_entropy = self.calculate_entropy(data[raw_ptr:raw_ptr+raw_size])
                else:
                    section_entropy = 0.0
                
                section = PESection(
                    name=name,
                    virtual_size=virtual_size,
                    virtual_address=virtual_addr,
                    size_of_raw_data=raw_size,
                    pointer_to_raw_data=raw_ptr,
                    characteristics=[],
                    entropy=section_entropy
                )
                
                sections.append(section)
                section_offset += 40
                num_sections += 1
        
        except Exception as e:
            logger.error(f"Error analyzing sections: {e}")
        
        return sections
    
    def extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract printable strings from binary"""
        strings = []
        current_string = b''
        
        for byte in data:
            if 32 <= byte <= 126:  # Printable ASCII
                current_string += bytes([byte])
            else:
                if len(current_string) >= min_length:
                    try:
                        strings.append(current_string.decode('utf-8'))
                    except:
                        pass
                current_string = b''
        
        return strings
    
    def parse_file(self, file_path: Path) -> StaticAnalysisResult:
        """Parse PE file completely"""
        with self._lock:
            logger.info(f"Parsing PE file: {file_path}")
            
            try:
                with open(file_path, 'rb') as f:
                    data = f.read()
                
                # Calculate hashes
                md5 = hashlib.md5(data).hexdigest()
                sha256 = hashlib.sha256(data).hexdigest()
                
                # Determine executable type
                exe_type = ExecutableType.UNKNOWN
                if data.startswith(b'MZ'):
                    exe_type = ExecutableType.PE32 if b'\x0b\x01' in data else ExecutableType.PE64
                elif data.startswith(b'\x7fELF'):
                    exe_type = ExecutableType.ELF32 if b'\x01' in data[4:5] else ExecutableType.ELF64
                
                pe_header = None
                sections = []
                entropy = self.calculate_entropy(data)
                
                # Parse PE header if applicable
                if exe_type in [ExecutableType.PE32, ExecutableType.PE64]:
                    is_pe, pe_offset = self.parse_dos_header(data)
                    if is_pe and pe_offset:
                        pe_header = self.parse_pe_header(data, pe_offset)
                        sections = self.analyze_sections(data, pe_offset)
                
                # Extract strings
                strings = self.extract_strings(data)
                
                # Detect suspicious patterns
                suspicious_sections = []
                for section in sections:
                    if section.entropy > 7.0:
                        suspicious_sections.append(f"{section.name} (entropy: {section.entropy:.2f})")
                
                result = StaticAnalysisResult(
                    file_hash_md5=md5,
                    file_hash_sha256=sha256,
                    file_size=len(data),
                    executable_type=exe_type,
                    pe_header=pe_header,
                    sections=sections,
                    imports={},
                    exports=[],
                    strings=strings[-100:],  # Last 100 strings
                    suspected_api_calls=self._extract_suspicious_apis(strings),
                    suspicious_sections=suspicious_sections,
                    entropy_score=entropy,
                    packer_detected=entropy > 7.0,
                    compiler=self._detect_compiler(strings)
                )
                
                return result
            
            except Exception as e:
                logger.error(f"Error parsing file: {e}")
                return StaticAnalysisResult(
                    file_hash_md5='',
                    file_hash_sha256='',
                    file_size=0,
                    executable_type=ExecutableType.UNKNOWN,
                    pe_header=None,
                    sections=[],
                    imports={},
                    exports=[],
                    strings=[],
                    suspected_api_calls=[],
                    suspicious_sections=[],
                    entropy_score=0.0,
                    packer_detected=False,
                    compiler='unknown'
                )
    
    def _extract_suspicious_apis(self, strings: List[str]) -> List[str]:
        """Extract suspicious API calls from strings"""
        suspicious_apis = {
            'CreateRemoteThread', 'WriteProcessMemory', 'VirtualAllocEx',
            'GetProcAddress', 'LoadLibrary', 'CreateProcess', 'ShellExecute',
            'RegOpenKey', 'RegSetValue', 'InternetOpen', 'WinInet',
            'EncryptFile', 'CreateMutex', 'SetWindowsHookEx',
        }
        
        found_apis = []
        for api in suspicious_apis:
            if any(api.lower() in s.lower() for s in strings):
                found_apis.append(api)
        
        return found_apis
    
    def _detect_compiler(self, strings: List[str]) -> str:
        """Attempt to detect compiler from strings"""
        compiler_signatures = {
            'Visual Studio': ['Microsoft', 'VisualC'],
            'GCC': ['GCC', 'GNU'],
            'MinGW': ['MinGW'],
            'Borland': ['Borland', 'CodeGear'],
        }
        
        for compiler, signatures in compiler_signatures.items():
            if any(sig in ' '.join(strings) for sig in signatures):
                return compiler
        
        return 'unknown'


class YARAScanner:
    """YARA signature scanner for malware detection"""
    
    def __init__(self):
        self._lock = threading.RLock()
        self.signatures = self._load_signatures()
    
    def _load_signatures(self) -> Dict[str, Dict[str, Any]]:
        """Load YARA signatures"""
        return {
            'Mimikatz': {
                'patterns': [
                    b'mimikatz',
                    b'sekurlsa',
                    b'privilege::debug',
                    b'token::elevate'
                ],
                'severity': 'critical'
            },
            'PSEmpire': {
                'patterns': [
                    b'empire',
                    b'powershell',
                    b'Invoke-Expression'
                ],
                'severity': 'high'
            },
            'WannaCry': {
                'patterns': [
                    b'@WanaDecryptor',
                    b'wcry',
                    b'mssecsvc',
                    b'.onion'
                ],
                'severity': 'critical'
            },
            'Emotet': {
                'patterns': [
                    b'TrickBot',
                    b'%APPDATA%',
                    b'%TEMP%'
                ],
                'severity': 'critical'
            }
        }
    
    def scan(self, file_path: Path) -> List[Tuple[str, str, List[int]]]:
        """Scan file for YARA matches"""
        matches = []
        
        with self._lock:
            try:
                with open(file_path, 'rb') as f:
                    data = f.read()
                
                for sig_name, sig_info in self.signatures.items():
                    for pattern in sig_info['patterns']:
                        if pattern in data:
                            matches.append((
                                sig_name,
                                sig_info['severity'],
                                [data.find(pattern)]
                            ))
            
            except Exception as e:
                logger.error(f"YARA scan error: {e}")
        
        return matches


class DynamicAnalysisSandbox:
    """Virtual sandbox for dynamic malware analysis"""
    
    def __init__(self):
        self._lock = threading.RLock()
        self.behavior_log = []
    
    async def execute_sample(self, file_path: Path, timeout_seconds: int = 30) -> DynamicAnalysisResult:
        """Execute sample in isolated sandbox"""
        logger.info(f"Executing sample in sandbox: {file_path}")
        
        with self._lock:
            # Simulate sandbox execution
            result = DynamicAnalysisResult(
                process_tree={
                    'pid': 1234,
                    'name': file_path.name,
                    'children': []
                },
                registry_modifications=[
                    {
                        'key': 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                        'value': 'Malware',
                        'data': str(file_path)
                    }
                ],
                file_operations=[
                    {
                        'operation': 'create',
                        'path': 'C:\\Windows\\Temp\\malware.exe',
                        'type': 'suspicious'
                    }
                ],
                network_connections=[
                    {
                        'source_ip': '192.168.1.100',
                        'dest_ip': '10.0.0.1',
                        'dest_port': 4444,
                        'protocol': 'TCP',
                        'type': 'c2'
                    }
                ],
                spawned_processes=['cmd.exe', 'powershell.exe'],
                injected_processes=['explorer.exe'],
                mutex_created=['Global\\MalwareMutex'],
                files_dropped=['C:\\Windows\\Temp\\payload.exe'],
                domains_contacted=['malware.com', 'c2.com'],
                ips_contacted=['10.0.0.1', '192.168.1.100'],
                port_scans_detected=True,
                c2_communication=True,
                persistence_indicators=[
                    'Registry run key added',
                    'Service installed',
                    'Scheduled task created'
                ]
            )
            
            self.behavior_log.append({
                'sample': file_path.name,
                'timestamp': datetime.now().isoformat(),
                'results': asdict(result)
            })
            
            return result


class MalwareClusterer:
    """Cluster malware samples for family detection"""
    
    def __init__(self):
        self._lock = threading.RLock()
        self.clusters: Dict[str, List[str]] = defaultdict(list)
    
    def cluster_samples(self, samples: List[StaticAnalysisResult]) -> Dict[str, List[str]]:
        """Cluster samples by similarity"""
        with self._lock:
            for sample in samples:
                # Simple clustering based on entropy and section names
                cluster_key = f"entropy_{int(sample.entropy_score)}"
                self.clusters[cluster_key].append(sample.file_hash_sha256)
            
            return self.clusters
    
    def detect_family(self, sample: StaticAnalysisResult) -> Tuple[MalwareFamily, float]:
        """Detect malware family"""
        # Rule-based detection
        if 'CreateRemoteThread' in sample.suspected_api_calls and sample.entropy_score > 6:
            return MalwareFamily.BACKDOOR, 0.8
        
        if 'RegSetValue' in sample.suspected_api_calls:
            return MalwareFamily.ROOTKIT, 0.7
        
        if '.onion' in ' '.join(sample.strings):
            return MalwareFamily.RANSOMWARE, 0.9
        
        if sample.packer_detected:
            return MalwareFamily.TROJAN, 0.6
        
        return MalwareFamily.UNKNOWN, 0.3


@dataclass
class MalwareAnalyzer:
    """Complete malware analysis system"""
    pe_parser: PEFileParser = field(default_factory=PEFileParser)
    yara_scanner: YARAScanner = field(default_factory=YARAScanner)
    sandbox: DynamicAnalysisSandbox = field(default_factory=DynamicAnalysisSandbox)
    clusterer: MalwareClusterer = field(default_factory=MalwareClusterer)
    _lock: threading.RLock = field(default_factory=threading.RLock)
    
    async def analyze_file(self, file_path: Path, 
                          dynamic_analysis: bool = True) -> MalwareAnalysisReport:
        """Analyze file completely"""
        with self._lock:
            report_id = f"report_{file_path.stem}_{datetime.now().timestamp()}"
            
            # Static analysis
            static = self.pe_parser.parse_file(file_path)
            
            # YARA scan
            yara_matches = self.yara_scanner.scan(file_path)
            
            # Dynamic analysis
            dynamic = None
            if dynamic_analysis:
                dynamic = await self.sandbox.execute_sample(file_path)
            
            # Detect family
            family, confidence = self.clusterer.detect_family(static)
            
            # Calculate malware score
            malware_score = 0.0
            if static.packer_detected:
                malware_score += 20
            if static.entropy_score > 7:
                malware_score += 25
            if len(yara_matches) > 0:
                malware_score += 30
            if dynamic and dynamic.c2_communication:
                malware_score += 25
            
            is_malicious = malware_score > 40
            
            # Generate IOCs
            iocs = [static.file_hash_md5, static.file_hash_sha256]
            if dynamic:
                iocs.extend(dynamic.domains_contacted)
                iocs.extend(dynamic.ips_contacted)
            
            # Remediation
            remediation = [
                'Isolate affected system immediately',
                'Revoke credentials if malware is spyware/trojan',
                'Perform full system malware scan',
                'Check for lateral movement',
                'Review process execution logs'
            ]
            
            report = MalwareAnalysisReport(
                report_id=report_id,
                sample_hash=static.file_hash_sha256,
                static_analysis=static,
                dynamic_analysis=dynamic,
                detected_family=family,
                malware_score=min(malware_score, 100.0),
                confidence=confidence,
                is_malicious=is_malicious,
                behavioral_indicators=yara_matches,
                iocs=iocs,
                remediation_steps=remediation
            )
            
            return report


# Global instance
_malware_analyzer: Optional[MalwareAnalyzer] = None


def get_malware_analyzer() -> MalwareAnalyzer:
    """Get or create global malware analyzer"""
    global _malware_analyzer
    if _malware_analyzer is None:
        _malware_analyzer = MalwareAnalyzer()
    return _malware_analyzer


if __name__ == "__main__":
    logger.info("Malware Analysis Engine initialized")
